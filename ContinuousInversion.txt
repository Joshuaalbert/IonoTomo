
import numpy as np
from sympy import symbols,sqrt,sech,Rational,lambdify
from sympy.vector import CoordSysCartesian
import time as ttime
import astropy.coordinates as ac
import astropy.units as au
import astropy.time as at
from scipy.integrate import simps
#my things
from FermatPrincipleCartesian import *
from Geometry import *
from Symbolic import *
from RealData import PrepareData
from IRI import *

###
# Forward model defines the symbolic kernel and it's derivative wrt to an ordered parameter list (index + map)
# It then performs tracing to derivate the ray trajectories.
# The forward model is then functionals along the ray tracjectories.
# Cached ray trajectories speeds the process.
# Parallel computation of ray trajectories is possible (numThreads = 1).
###

class ForwardModel(SolitonModel):
    def __init__(self,numAntennas,numDirections,numTimes,pathlength=2000,filename=None,numThreads=1,**kwargs):
        '''The ionosphere is modelled as the IRI plus a set of solitons
        with time coherence imposed via linear coherence over short time intervals'''
        super(ForwardModel,self).__init__(**kwargs)
        self.filename=filename
        self.numDirections = numDirections
        self.numTimes = numTimes
        self.numAntennas = numAntennas
        self.pathlength = pathlength
        #add forward params
        self.forwardParams = {}
        i = 0
        while i < self.numDirections:
            j = 0
            while j < self.numTimes:
                self.forwardParams["rho_{0}_{1}".format(i,j)] = 9e13/pathlength#inital guess at tec
                j += 1
            i += 1
        self.initForwardParams = self.getForwardParams()
        self.makeSymbolicKernel()
        
    def getForwardParams(self):
        params = np.zeros(self.numTimes*self.numDirections)
        i = 0
        while i < self.numDirections:
            j = 0
            while j < self.numTimes:
                params[i*self.numTimes + j] = self.forwardParams["rho_{0}_{1}".format(i,j)]
                j += 1
            i += 1
        return params
        
    def setForwardParams(self,params):
        i = 0
        while i < self.numDirections:
            j = 0
            while j < self.numTimes:
                self.forwardParams["rho_{0}_{1}".format(i,j)] = params[i*self.numTimes + j]
                j += 1
            i += 1
            
    def setModelParams(self,params):
        '''set params for entire model'''
        #should be able to put into dict?
        solitonParams = params[:8*len(self.solitons)]
        forwardParams = params[8*len(self.solitons):]
        self.setSolitonParams(solitonParams)
        self.setForwardParams(forwardParams)
    
    def getModelParams(self):
        '''set params for entire model'''
        #should be able to put into dict?
        params = np.zeros(8*len(self.solitons) + self.numDirections*self.numTimes)
        params[:8*len(self.solitons)] = self.getSolitonParams()
        params[8*len(self.solitons):] = self.getForwardParams()
        return params
    
    def getModelParamDict(self):
        paramDict = self.getSolitonParamDict()
        for key in self.forwardParams.keys():
            paramDict[key] = self.forwardParams[key]
        return paramDict
    
    def makeSymbolicKernel(self):
        '''Generate symbolic forward kernel and derivative wrt beta'''
        print("Generating symbolic kernel for {0} rays".format(self.numAntennas*self.numDirections*self.numTimes))
        t1 = ttime.time()
        neFunc = self.solitonModelSymbolic
        paramDict = self.getModelParamDict()
        #self.neLamb = lambdify(symbols('x y z t'),neFunc)
        self.kernelSymbolic = {}
        self.JkernelSymbolic = {}
        dirIdx = 0
        while dirIdx < self.numDirections:
            #print("{0:0.1f}% done".format(100.*dirIdx/float(self.numDirections)))
            timeIdx = 0
            while timeIdx < self.numTimes:
                G = (neFunc - symbols("rho_{0}_{1}".format(dirIdx,timeIdx))) / Rational(1e13)#units of tecu
                J = []
                for param in paramDict.keys():
                    J.append(G.diff(param))
                antIdx = 0
                while antIdx < self.numAntennas:
                    datumIdx = self.getDatumIdx(antIdx,dirIdx,timeIdx)
                    self.kernelSymbolic[datumIdx] = G
                    self.JkernelSymbolic[datumIdx] = J
                    antIdx += 1
                timeIdx += 1
            dirIdx += 1
        print("Time to generate symbolic kernel: {0} s".format(ttime.time()-t1))
        return self.kernelSymbolic,self.JkernelSymbolic
    
    def generateKernel(self,params=None):
        '''Create the kernel G^i such that int_(R^i) G^i ds = data^i
        
        d^i(t) = int ne(beta;x,y,z,t) R^i(x,y,z,t) - rho^antIdx(t) R^i(x,y,z,t) - psi(t) R^i(x,y,z,t) dV
        kernel is three terms:
        
        ne(beta;x,y,z,t) R^i(x,y,z,t)
            path integral of ne along ray^i
            
        rho^antIdx(t) R^i(x,y,z,t) **not incorperated yet**
            antenna based gain for direction i (systematics that are not spatially correlated)
        
        psi(t) R^i(x,y,z,t)
            offset which should equal int ne(beta;x,y,z,t) R^j(x,y,z,t) - rho^j(t) R^i(x,y,z,t) for some j
        '''
        print("Generating lambda kernel for {0} rays".format(self.numAntennas*self.numDirections*self.numTimes))
        t1 = ttime.time()
        if params is not None:
            self.setModelParams(params)
        paramDict = self.getModelParamDict()
        self.kernel = {}
        self.Jkernel = {}
        dirIdx = 0
        while dirIdx < self.numDirections:
            print("{0:0.1f}% done".format(100.*dirIdx/float(self.numDirections)))
            timeIdx = 0
            while timeIdx < self.numTimes:
                datumIdx = self.getDatumIdx(0,dirIdx,timeIdx)
                kernel = lambdify(symbols('x y z t'),self.kernelSymbolic[datumIdx].subs(paramDict),'numpy')
                Jkernel = []
                for ji in self.JkernelSymbolic[datumIdx]:
                    Jkernel.append(lambdify(symbols('x y z t'),ji.subs(paramDict),'numpy'))
                antIdx = 0
                while antIdx < self.numAntennas:
                    datumIdx = self.getDatumIdx(antIdx,dirIdx,timeIdx)
                    self.kernel[datumIdx] = kernel
                    self.Jkernel[datumIdx] = Jkernel
                    antIdx += 1
                timeIdx += 1
            dirIdx += 1
        print("Time to generate lambda kernel: {0} s".format(ttime.time()-t1))
        return self.kernel,self.Jkernel
            
    def getDatumIdx(self,antIdx,dirIdx,timeIdx):
        idx = antIdx*self.numDirections*self.numTimes + dirIdx*self.numTimes + timeIdx
        return idx
    
    def getIndicies(self,datumIdx):
        timeIdx = datumIdx % self.numTimes
        dirIdx = ((datumIdx - timeIdx)/self.numTimes) % self.numDirections
        antIdx = (datumIdx - timeIdx - dirIdx*self.numTimes)/self.numDirections/self.numTimes
        return antIdx,dirIdx,antIdx
    
    def calcRays(self,inRays,N=100,load=False):
        
        generate = True
        if self.filename is not None and load:
            rays = np.load('{0}-rays.npz'.format(self.filename))['rays']
            generate = False
        if generate:    
            rays = {}
            #given the current ne model perform ray trace and forward model
            self.fermat =  Fermat(neFunc = self.generateSolitonModel(),type = 's')
            #n = 1
            #threads = []
            #for i in range(n):
            #    threads.append(FermatIntegrationThread(self.fermat,i))
            #    threads[i].start()

            #count = 0
            #jobs = {}
            for ray in inRays:
                datumIdx = ray.id
                antIdx,dirIdx,antIdx = self.getIndicies(datumIdx)
                origin = ac.SkyCoord(*(ray.origin*au.m),frame=self.enu).transform_to('itrs').cartesian.xyz.to(au.km).value
                direction = ac.SkyCoord(*ray.dir,frame=self.enu).transform_to('itrs').cartesian.xyz.value
                time = ray.time
                #jobs[datumIdx] = (count%n,threads[count % n].addJob(origin,direction,self.pathlength,time,N))
                x,y,z,s = self.fermat.integrateRay(origin,direction,self.pathlength,time=time,N=N)
                rays[datumIdx] = {'x':x,'y':y,'z':z,'s':s}
            if self.filename is not None:
                np.savez('{0}-rays.npz'.format(self.filename),rays=rays)
        return rays
    def doForward(self,inRays,N=100,load=False):
        '''Run forward model by calculating the ray trajectories from which kernels can be integrated.
        Could also add the kernel as an euler eqns too in the future.
        ``antennas`` is list of ENU frame origins of antennas
        ``directions`` is list of ENU frame directions
        ``times`` is list of astropy.time objects
        ``N`` is the resolution along path to split'''
        self.generateKernel(params=None)
        rays = self.calcRays(inRays,N=N,load=load)
        d = np.zeros(len(inRays))
        count = 0
        for ray in inRays:
            datumIdx = ray.id
            #kernel
            GLamb = self.kernel[datumIdx]
            G = np.zeros(N)
            i = 0
            for xi,yi,zi in zip(rays[datumIdx]['x'],rays[datumIdx]['y'],rays[datumIdx]['z']):
                #print (xi,yi,zi)
                G[i] = GLamb(xi,yi,zi,ray.time)
                #print(ne[i])
                i += 1
            d[count] = simps(G,rays[datumIdx]['s'])
            count += 1      
        return d
    def doJkernel(self,inRays,N=100,load=False):
        '''Run forward model by calculating the ray trajectories from which kernels can be integrated.
        Could also add the kernel as an euler eqns too in the future.
        ``antennas`` is list of ENU frame origins of antennas
        ``directions`` is list of ENU frame directions
        ``times`` is list of astropy.time objects
        ``N`` is the resolution along path to split'''
        self.generateKernel(params=None)
        paramDict = self.getModelParamDict()
        rays = self.calcRays(inRays,N=N,load=load)
        Jkernel = np.zeros([len(inRays),len(paramDict)])
        rayIdx = 0
        for ray in inRays:
            datumIdx = ray.id
            #kernel
            paramIdx = 0
            for JLamb in self.Jkernel[datumIdx]:
                J = np.zeros(N)
                i = 0
                for xi,yi,zi in zip(rays[datumIdx]['x'],rays[datumIdx]['y'],rays[datumIdx]['z']):
                    #print (xi,yi,zi)
                    J[i] = JLamb(xi,yi,zi,ray.time)
                    #print(ne[i])
                    i += 1
                Jkernel[rayIdx,paramIdx] = simps(J,rays[datumIdx]['s'])
                paramIdx += 1
            rayIdx += 1      
        return Jkernel
            
def LMSolContinous(dataDict,mu = 0.5):
    '''
    ``rays`` origin and dir are in ENU frame.
    data is d = dtec = int_i ne ds - int_i0 ne ds.
        neFunc = f(beta)
        g(beta) = int_i f(beta) + rho_i ds - int_i0 f(beta) + rho_i0 ds
        minimize (dobs - d)Cdinv(dobs - d) + mu (log(neFunc)  - log(neprior))Cminv(log(neFunc) - log(neprior))
        
        Solve in continuous basis.
    Steps:
    1. propagate rays
    2. 
    d = g(m)
    G = 
    '''
    Nsol = 5
    print("Constructing the model with {0} solitons".format(Nsol))
    model = ForwardModel(dataDict['numAntennas'],
                         dataDict['numDirections'],
                         dataDict['numTimes'],
                         pathlength=2000,
                         numSolitons=Nsol,
                         filename='Wendys-bootes-inversion')
    params = model.getModelParams()
    rays = model.calcRays(dataDict['rays'],load=True)
    plotWavefront(lambda x,y,z : model.generateSolitonModel()(x,y,z,0),rays,*getSolitonCube(model))
    g = model.doForward(dataDict['rays'],N=100,load=True)
    dd = dataDict['dtec'] - g
    print("Computing observation covariance.")
    Cd = np.eye(np.size(params))*np.var(g)*1.2
    Cdinv = np.linalg.pinv(Cd)
    J = self.doJkernel(inRays,N=100,load=True)
    S = J.transpose().dot(Cdinv).dot(J)
    T = np.linalg.pinv(S)
    
    wdd = J.transpose().dot(Cdinv).dot(dd)
    dbeta = T.dot(wdd)
    params += dbeta
    model.setModelParams(params)
    #monte carlo L.Cminv.L
    #neFunc = model.solitonModelSymbolic
    #paramDict = self.getModelParamDict()
    #L = []
    #for param i paramDict.keys():
    #    L.append(neFunc.diff(param))
    
    
def testForwardProblem():
    sol = SolitonModel(8)
    
    neFunc = sol.generateSolitonModel()

    theta = np.linspace(-np.pi/8.,np.pi/8.,2)
    #phi = np.linspace(0,2*np.pi,6)
    rays = []
    origin = ac.ITRS(sol.enu.location).cartesian.xyz.to(au.km).value
    for t in theta:
        for p in theta:
            direction = ac.SkyCoord(np.sin(t),
                                    np.sin(p),
                                    1.,frame=sol.enu).transform_to('itrs').cartesian.xyz.value
            rays.append(Ray(origin,direction))
    forwardProblem = ForwardProblem(sol)
    times = np.zeros(len(rays))
    d = forwardProblem.doForward(rays,times,N=1000)
    print(d)
    #plotWavefront(f.nFunc.subs({'t':0}),rays,*getSolitonCube(sol))
    #plotFuncCube(f.nFunc.subs({'t':0}), *getSolitonCube(sol),rays=rays)
    
    
if __name__ == '__main__':
    np.random.seed(1234)
    #testForwardProblem()
    dataDict = PrepareData(infoFile='SB120-129/WendysBootes.npz',
                           dataFolder='SB120-129/',
                           timeStart = 0, timeEnd = 0,
                           arrayFile='arrays/lofar.hba.antenna.cfg',load=True)
    model = ForwardModel(dataDict['numAntennas'],dataDict['numDirections'],dataDict['numTimes'],pathlength=2000,numSolitons=1,filename='testmodel.npz')
    model.doForward(dataDict['rays'])
    LMSolContinous(dataDict,mu = 0.5)
    #LMSolContinous(**dataDict)

import pylab as plt
plt.hist(dataDict['dtec'])
plt.show()


